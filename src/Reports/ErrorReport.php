<?php

declare(strict_types=1);

namespace Inspector\MCPServer\Reports;

use DateInterval;
use DateTime;

/**
 * ErrorReport - Generates comprehensive error reports for AI-assisted debugging
 *
 * This class transforms Inspector error data into structured reports optimized
 * for LLM analysis and developer assistance in PHP applications.
 */
class ErrorReport
{
    private array $error;

    public function __construct(array $error)
    {
        $this->error = $error;
    }

    /**
     * Generate a comprehensive error report for LLM analysis
     *
     * @return string Formatted error report
     */
    public function generate(): string
    {
        $sections = [
            $this->generateErrorSummary(),
            $this->generateErrorContext(),
            $this->generateCodeAnalysis(),
            $this->generateExistingFix(),
            $this->generateActionableInsights()
        ];

        return implode("\n\n", array_filter($sections));
    }

    private function generateErrorSummary(): string
    {
        $message = $this->error['message'] ?? 'Unknown error';
        $class = $this->error['class'] ?? 'Unknown';
        $hash = $this->error['hash'] ?? 'N/A';
        $occurrences = $this->error['nth'] ?? 1;

        return "ERROR SUMMARY\n" .
            "=============\n" .
            "Type: {$class}\n" .
            "Message: {$message}\n" .
            "Error Hash: {$hash}\n" .
            "Occurrence Count: {$occurrences} time(s)\n" .
            "Severity: " . $this->determineSeverity();
    }

    private function generateErrorContext(): string
    {
        $context = "ERROR CONTEXT\n" .
            "=============\n";

        // Primary error location (from stack trace)
        if (isset($this->error['file']) && isset($this->error['line'])) {
            $context .= "Stack Trace Origin:\n" .
                "File: {$this->error['file']}\n" .
                "Line: {$this->error['line']}\n\n";
        }

        // Application source location (most important)
        if (isset($this->error['app_file'])) {
            $appFile = $this->error['app_file'];
            $context .= "APPLICATION SOURCE (Primary Investigation Target):\n" .
                "File: {$appFile['file']}\n" .
                "Line: {$appFile['line']}\n";

            if (isset($appFile['code'])) {
                $context .= "```php\n";
                $context .= $appFile['code'] . "\n";
                $context .= "```\n\n";
            }
        }

        return $context;
    }

    private function generateCodeAnalysis(): string
    {
        if (!isset($this->error['app_file']['code'])) {
            return '';
        }

        $analysis = "CODE ANALYSIS\n" .
            "=============\n";

        $message = $this->error['message'] ?? '';
        $line = $this->error['app_file']['line'] ?? 0;

        // Analyze common error patterns
        if (str_contains($message, 'Attempt to read property')) {
            $analysis .= "Error Pattern: NULL PROPERTY ACCESS\n" .
                "Issue: Attempting to access a property on a null object\n" .
                "Focus Line: {$line}\n" .
                "Investigation Priority: Check for null values before property access\n\n";
        } elseif (str_contains($message, 'Call to a member function')) {
            $analysis .= "Error Pattern: NULL METHOD CALL\n" .
                "Issue: Attempting to call a method on a null object\n" .
                "Focus Line: {$line}\n" .
                "Investigation Priority: Verify object instantiation before method calls\n\n";
        } elseif (str_contains($message, 'Undefined array key') || str_contains($message, 'Undefined index')) {
            $analysis .= "Error Pattern: UNDEFINED ARRAY ACCESS\n" .
                "Issue: Accessing an array key that doesn't exist\n" .
                "Focus Line: {$line}\n" .
                "Investigation Priority: Validate array keys before access\n\n";
        }

        // Extract potential variable names from error message
        $analysis .= $this->extractVariableContext();

        return $analysis;
    }

    private function generateExistingFix(): string
    {
        if (!isset($this->error['fix'])) {
            return '';
        }

        $fix = $this->error['fix'];
        $fixReport = "INSPECTOR AI ANALYSIS\n" .
            "====================\n";

        if (isset($fix['platform'])) {
            $fixReport .= "Detected Platform: {$fix['platform']}\n";
        }

        if (isset($fix['language'])) {
            $fixReport .= "Language: {$fix['language']}\n";
        }

        if (isset($fix['proposal'])) {
            $fixReport .= "---\n" . $fix['proposal'] . "\n---\n";
        }

        $fixReport .= "\nNOTE: This fix was generated by Inspector's AI. Please review and adapt as needed for your specific use case.\n";

        return $fixReport;
    }

    private function generateActionableInsights(): string
    {
        $insights = "ACTIONABLE INSIGHTS\n" .
            "==================================\n";

        if (isset($this->error['nth']) && $this->error['nth'] > 1) {
            $insights .= "This is a recurring error ({$this->error['nth']} occurrences) - prioritize fixing\n";
        }

        $insights .= "\nDebugging Strategy:\n";
        $insights .= "- Focus investigation on the APPLICATION SOURCE file listed above\n";
        $insights .= "- The stack trace origin may be in a library - trace back to the application code\n";
        $insights .= "- Consider edge cases and unexpected input scenarios\n";

        if (isset($this->error['app_file']['file'])) {
            $insights .= "\nNext Steps:\n";
            $insights .= "- Open file: {$this->error['app_file']['file']}\n";
            $insights .= "- Navigate to line: {$this->error['app_file']['line']}\n";
            $insights .= "- Examine the surrounding code context\n";
        }

        return $insights;
    }

    private function extractVariableContext(): string
    {
        $message = $this->error['message'] ?? '';
        $context = '';

        // Extract property names from error messages
        if (preg_match('/property "([^"]+)"/', $message, $matches)) {
            $context .= "Problematic Property: {$matches[1]}\n";
        }

        // Extract method names from error messages
        if (preg_match('/member function ([^\s]+)/', $message, $matches)) {
            $context .= "Problematic Method: {$matches[1]}\n";
        }

        // Extract array keys from error messages
        if (preg_match('/array key "([^"]+)"/', $message, $matches)) {
            $context .= "Missing Array Key: {$matches[1]}\n";
        }

        return $context;
    }

    private function determineSeverity(): string
    {
        $occurrences = $this->error['nth'] ?? 1;
        $message = $this->error['message'] ?? '';

        if ($occurrences >= 10) {
            return 'CRITICAL (High frequency)';
        } elseif ($occurrences >= 5) {
            return 'HIGH (Multiple occurrences)';
        } elseif (str_contains($message, 'Fatal error')) {
            return 'CRITICAL (Fatal)';
        } else {
            return 'MEDIUM';
        }
    }

    private function analyzeErrorPattern(): string
    {
        $occurrences = $this->error['nth'] ?? 1;

        if (isset($this->error['created_at']) && isset($this->error['last_seen_at'])) {
            $firstSeen = new DateTime($this->error['created_at']);
            $lastSeen = new DateTime($this->error['last_seen_at']);
            $duration = $lastSeen->diff($firstSeen);

            if ($duration->h < 1 && $occurrences > 5) {
                return 'Rapid succession (potential loop or high-traffic trigger)';
            } elseif ($duration->d > 1 && $occurrences > 1) {
                return 'Intermittent over time (environment or data-dependent)';
            }
        }

        return $occurrences > 1 ? 'Recurring' : 'Single occurrence';
    }

    private function formatDuration(DateInterval $duration): string
    {
        if ($duration->d > 0) {
            return "{$duration->d} day(s), {$duration->h} hour(s)";
        } elseif ($duration->h > 0) {
            return "{$duration->h} hour(s), {$duration->i} minute(s)";
        } else {
            return "{$duration->i} minute(s), {$duration->s} second(s)";
        }
    }
}
